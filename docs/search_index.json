[["thursday-september-21-2022.html", "Thursday, September 21, 2022 Today Simple feature data frames Making a boundary map Fills Overlays Map projections", " Thursday, September 21, 2022 Today Making maps Simple feature data frames Geographic visualization of data is important to geographers and environmental scientists. There are lots of tools available for geo visualization from full-scale GIS applications such as ArcGIS and QGIS to web-based tools like Google maps. Using code to make maps (instead of point and click) has the benefit of transparency and reproducibility. Simple features (simple feature access) refers to a standard that describes how objects in the real world are represented in computers. Emphasis is on the spatial geometry of the objects. The standard also describes how such objects are stored in and retrieved from databases, and which geometrical operations are defined for them. The simple feature standard is implemented in spatial databases (such as PostGIS), commercial GIS (e.g., ESRI ArcGIS). R has an implementation in the {sf} package. One type of spatial data file is called a shapefile. As an example, the U.S. census information at the state and territory level in a file called cb_2018_us_state_5m.shp. https://www.census.gov/geographies/mapping-files/time-series/geo/carto-boundary-file.html A shapefile encodes points, lines, and polygons in geographic space, and is actually a set of files. Shapefiles appear with a .shp extension and with accompanying files ending in .dbf and .prj. .shp stores the geographic coordinates of the geographic features (e.g. country, state, county) .dbf stores data associated with the geographic features (e.g. unemployment rates) .prj stores information about the projection of the coordinates in the shapefile To get a shapefile into R all the files need to be in the same folder (directory). As an example, you import the census data with the sf::st_read() function from the {sf} package. You assign to the object usa.sf the contents of the spatial data frame. usa.sf &lt;- sf::st_read(dsn = &quot;data/cb_2018_us_state_5m&quot;) ## Reading layer `cb_2018_us_state_5m&#39; from data source ## `/Users/jameselsner/Desktop/ClassNotes/QG-2022/data/cb_2018_us_state_5m&#39; ## using driver `ESRI Shapefile&#39; ## Simple feature collection with 56 features and 9 fields ## Geometry type: MULTIPOLYGON ## Dimension: XY ## Bounding box: xmin: -179.1473 ymin: -14.55255 xmax: 179.7785 ymax: 71.35256 ## Geodetic CRS: NAD83 The output includes information about the file. The object shows up in our environment as a data frame with 56 observations and 10 variables. Each observation is either a state or territory. The class() function tells us the type of data frame and the names() function list the variable names. class(usa.sf) ## [1] &quot;sf&quot; &quot;data.frame&quot; names(usa.sf) ## [1] &quot;STATEFP&quot; &quot;STATENS&quot; &quot;AFFGEOID&quot; &quot;GEOID&quot; &quot;STUSPS&quot; &quot;NAME&quot; ## [7] &quot;LSAD&quot; &quot;ALAND&quot; &quot;AWATER&quot; &quot;geometry&quot; The file is a simple feature (sf) data frame (data.frame). This means it behaves like a data frame but it also contains information about where the observations are located. The first several columns serve as identifiers. The variable ALAND is the land area (square meters) and the AWATER is the water area (sq. m). The last column labeled geometry contains information about location stored as a ‘feature.’ The function sf::st_geometry() list the first 5 geometries. sf::st_geometry(usa.sf) ## Geometry set for 56 features ## Geometry type: MULTIPOLYGON ## Dimension: XY ## Bounding box: xmin: -179.1473 ymin: -14.55255 xmax: 179.7785 ymax: 71.35256 ## Geodetic CRS: NAD83 ## First 5 geometries: ## MULTIPOLYGON (((-104.0535 41.15726, -104.0527 4... ## MULTIPOLYGON (((-122.3283 48.02134, -122.3217 4... ## MULTIPOLYGON (((-109.0502 31.48, -109.0498 31.4... ## MULTIPOLYGON (((-104.0577 44.99743, -104.0502 4... ## MULTIPOLYGON (((-106.6455 31.89867, -106.6408 3... The geometry type in this case is MULTIPOLYGON. A feature is an object in the real world. Often features will consist of a set of features. For instance, a tree is a feature but a set of trees in a forest is itself a feature. The trees are represented as points while the forest boundary as a polygon. Features have a geometry describing where on Earth the feature is located. They also have attributes, which describe other properties of the feature. More on spatial data in a few weeks. Making a boundary map The functions in the {ggplot2} package work with simple feature data frames to generate maps using the same grammar. The important function is geom_sf(). This function draws the geometries. For example, to draw a map showing the state and territorial boundaries first use ggplot() with the data argument specifying the simple feature data frame usa.sf and then add the geom_sf() function as a layer with the + symbol. library(ggplot2) ggplot(data = usa.sf) + geom_sf() Note: you don’t need the mapping = aes() function. The mapping is assumed based on the fact that there is a geometry column in the simple feature data frame. The geom_sf() function maps the east-west coordinate to the x aesthetic and the north-south coordinate to the y aesthetic. The map is not very informative. Let’s zoom into the contiguous states. What states/territories are there in the data frame usa.sf? usa.sf$NAME ## [1] &quot;Nebraska&quot; ## [2] &quot;Washington&quot; ## [3] &quot;New Mexico&quot; ## [4] &quot;South Dakota&quot; ## [5] &quot;Texas&quot; ## [6] &quot;California&quot; ## [7] &quot;Kentucky&quot; ## [8] &quot;Ohio&quot; ## [9] &quot;Alabama&quot; ## [10] &quot;Georgia&quot; ## [11] &quot;Wisconsin&quot; ## [12] &quot;Oregon&quot; ## [13] &quot;Pennsylvania&quot; ## [14] &quot;Mississippi&quot; ## [15] &quot;Missouri&quot; ## [16] &quot;North Carolina&quot; ## [17] &quot;Oklahoma&quot; ## [18] &quot;West Virginia&quot; ## [19] &quot;New York&quot; ## [20] &quot;Indiana&quot; ## [21] &quot;Kansas&quot; ## [22] &quot;Idaho&quot; ## [23] &quot;Nevada&quot; ## [24] &quot;Vermont&quot; ## [25] &quot;Montana&quot; ## [26] &quot;Minnesota&quot; ## [27] &quot;North Dakota&quot; ## [28] &quot;Hawaii&quot; ## [29] &quot;Arizona&quot; ## [30] &quot;Delaware&quot; ## [31] &quot;Rhode Island&quot; ## [32] &quot;Colorado&quot; ## [33] &quot;Utah&quot; ## [34] &quot;Virginia&quot; ## [35] &quot;Wyoming&quot; ## [36] &quot;Louisiana&quot; ## [37] &quot;Michigan&quot; ## [38] &quot;Massachusetts&quot; ## [39] &quot;Florida&quot; ## [40] &quot;United States Virgin Islands&quot; ## [41] &quot;Connecticut&quot; ## [42] &quot;New Jersey&quot; ## [43] &quot;Maryland&quot; ## [44] &quot;South Carolina&quot; ## [45] &quot;Maine&quot; ## [46] &quot;New Hampshire&quot; ## [47] &quot;District of Columbia&quot; ## [48] &quot;Guam&quot; ## [49] &quot;Commonwealth of the Northern Mariana Islands&quot; ## [50] &quot;American Samoa&quot; ## [51] &quot;Iowa&quot; ## [52] &quot;Puerto Rico&quot; ## [53] &quot;Arkansas&quot; ## [54] &quot;Tennessee&quot; ## [55] &quot;Illinois&quot; ## [56] &quot;Alaska&quot; To zoom in you keep only rows corresponding to states (in the lower 48) from the simple feature data frame. Recall to pick out rows in a data frame you use the dplyr::filter() function from the {dplyr} package. First you need to get a list of all the states you want to keep. The state.name vector object contains all 50 state names. This is like the month.abb vector you saw earlier. state.name ## [1] &quot;Alabama&quot; &quot;Alaska&quot; &quot;Arizona&quot; &quot;Arkansas&quot; ## [5] &quot;California&quot; &quot;Colorado&quot; &quot;Connecticut&quot; &quot;Delaware&quot; ## [9] &quot;Florida&quot; &quot;Georgia&quot; &quot;Hawaii&quot; &quot;Idaho&quot; ## [13] &quot;Illinois&quot; &quot;Indiana&quot; &quot;Iowa&quot; &quot;Kansas&quot; ## [17] &quot;Kentucky&quot; &quot;Louisiana&quot; &quot;Maine&quot; &quot;Maryland&quot; ## [21] &quot;Massachusetts&quot; &quot;Michigan&quot; &quot;Minnesota&quot; &quot;Mississippi&quot; ## [25] &quot;Missouri&quot; &quot;Montana&quot; &quot;Nebraska&quot; &quot;Nevada&quot; ## [29] &quot;New Hampshire&quot; &quot;New Jersey&quot; &quot;New Mexico&quot; &quot;New York&quot; ## [33] &quot;North Carolina&quot; &quot;North Dakota&quot; &quot;Ohio&quot; &quot;Oklahoma&quot; ## [37] &quot;Oregon&quot; &quot;Pennsylvania&quot; &quot;Rhode Island&quot; &quot;South Carolina&quot; ## [41] &quot;South Dakota&quot; &quot;Tennessee&quot; &quot;Texas&quot; &quot;Utah&quot; ## [45] &quot;Vermont&quot; &quot;Virginia&quot; &quot;Washington&quot; &quot;West Virginia&quot; ## [49] &quot;Wisconsin&quot; &quot;Wyoming&quot; Let’s remove the rows corresponding to the names \"Alaska\" and \"Hawaii\". These are elements 2 and 11 so you create a new vector object called sn containing only the names of the lower 48. sn &lt;- state.name[c(-2, -11)] sn ## [1] &quot;Alabama&quot; &quot;Arizona&quot; &quot;Arkansas&quot; &quot;California&quot; ## [5] &quot;Colorado&quot; &quot;Connecticut&quot; &quot;Delaware&quot; &quot;Florida&quot; ## [9] &quot;Georgia&quot; &quot;Idaho&quot; &quot;Illinois&quot; &quot;Indiana&quot; ## [13] &quot;Iowa&quot; &quot;Kansas&quot; &quot;Kentucky&quot; &quot;Louisiana&quot; ## [17] &quot;Maine&quot; &quot;Maryland&quot; &quot;Massachusetts&quot; &quot;Michigan&quot; ## [21] &quot;Minnesota&quot; &quot;Mississippi&quot; &quot;Missouri&quot; &quot;Montana&quot; ## [25] &quot;Nebraska&quot; &quot;Nevada&quot; &quot;New Hampshire&quot; &quot;New Jersey&quot; ## [29] &quot;New Mexico&quot; &quot;New York&quot; &quot;North Carolina&quot; &quot;North Dakota&quot; ## [33] &quot;Ohio&quot; &quot;Oklahoma&quot; &quot;Oregon&quot; &quot;Pennsylvania&quot; ## [37] &quot;Rhode Island&quot; &quot;South Carolina&quot; &quot;South Dakota&quot; &quot;Tennessee&quot; ## [41] &quot;Texas&quot; &quot;Utah&quot; &quot;Vermont&quot; &quot;Virginia&quot; ## [45] &quot;Washington&quot; &quot;West Virginia&quot; &quot;Wisconsin&quot; &quot;Wyoming&quot; Now you filter the usa.sf data frame keeping only the rows that are listed in the vector of state names. Assign this spatial data frame the name usa_48.sf. usa_48.sf &lt;- usa.sf |&gt; dplyr::filter(NAME %in% sn) The function %in% finds only the rows in usa.sf with NAME equal to the names in the vector sn and the dplyr::filter() function chooses these rows. Now redraw the map using the usa_48.sf simple feature data frame. ggplot(data = usa_48.sf) + geom_sf() Since the map is a ggplot() object, it is modified like any other ggplot() graph. For example, you change the color of the map and the borders as follows. ggplot(data = usa_48.sf) + geom_sf(fill = &quot;skyblue&quot;, color = &quot;gray70&quot;) You can filter by state. Here you create a new simple feature data frame called Wisconsin.sf then draw the boundary. Wisconsin.sf &lt;- usa_48.sf |&gt; dplyr::filter(NAME == &quot;Wisconsin&quot;) ggplot(data = Wisconsin.sf) + geom_sf(fill = &quot;palegreen&quot;, color = &quot;black&quot;) Where is the state of Nebraska? Repeat but fill in Nebraska using the color brown. Nebraska.sf &lt;- usa_48.sf |&gt; dplyr::filter(NAME == &quot;Nebraska&quot;) ggplot(data = usa_48.sf) + geom_sf() + geom_sf(data = Nebraska.sf, fill = &quot;brown&quot;) You add layers with the + symbol as before. Boundaries serve as the background canvas for spatial data analysis. You usually need to add data to this canvas. Depending on the type of data, you either overlay it on top of the boundaries or use it to fill in the areas between the boundaries. Fills Choropleth maps (heat maps, thematic maps) map data values from a column in the simple feature data frame to the fill aesthetic. The aesthetic assigns colors to the various map areas (e.g. countries, states, counties, zip codes). Recall the column labeled AWATER contains the water area in square meters. Since the values are very large first divide by million (10^9) to get the values in 1000s of square kilometers. This is done with the mutate() function. usa_48.sf &lt;- usa_48.sf |&gt; dplyr::mutate(WaterArea_km2 = AWATER/10^9) Then create a choropleth map showing the water area by filling the area between the state borders with a color. This is done using the aes() function and the argument fill = WaterArea_km2. ggplot(data = usa_48.sf) + geom_sf(aes(fill = WaterArea_km2)) Note how this differs from just drawing the boundaries. In this case you use the aes() function with the fill aesthetic. The map is not very informative. large water area of Michigan which includes Lakes Michigan, Superior, and Huron has by far the most water area with most other states have a lot less. To change that use the logarithm of the area. The base 10 logarithm is 0 when the value is 1, 1 when the value is 10, 2 when the value is 100 and so on. This is seen with the log10() function. log10(c(1, 10, 100, 1000, 10000)) ## [1] 0 1 2 3 4 You convert the area to logarithms with the log10() function inside the aes() function as follows. ggplot(data = usa_48.sf) + geom_sf(aes(fill = log10(WaterArea_km2))) Another way to make the map more informative is to convert the continuous variable to a discrete variable and map the discrete values. In the {dplyr} package the cut_interval() function takes a continuous variable and makes n groups each having an equal range, cut_number() makes n groups with (approximately) equal numbers of observations; cut_width() makes groups of equal width. As an example, if you want a map with 5 colors with each color representing a state having a similar amount of water area you would use cut_number() and specify n = 5. You do this with the mutate() function to create a new variable (column) called WaterArea_cut. usa_48.sf &lt;- usa_48.sf |&gt; dplyr::mutate(WaterArea_cut = cut_number(WaterArea_km2, n = 5)) str(usa_48.sf) ## Classes &#39;sf&#39; and &#39;data.frame&#39;: 48 obs. of 12 variables: ## $ STATEFP : chr &quot;31&quot; &quot;53&quot; &quot;35&quot; &quot;46&quot; ... ## $ STATENS : chr &quot;01779792&quot; &quot;01779804&quot; &quot;00897535&quot; &quot;01785534&quot; ... ## $ AFFGEOID : chr &quot;0400000US31&quot; &quot;0400000US53&quot; &quot;0400000US35&quot; &quot;0400000US46&quot; ... ## $ GEOID : chr &quot;31&quot; &quot;53&quot; &quot;35&quot; &quot;46&quot; ... ## $ STUSPS : chr &quot;NE&quot; &quot;WA&quot; &quot;NM&quot; &quot;SD&quot; ... ## $ NAME : chr &quot;Nebraska&quot; &quot;Washington&quot; &quot;New Mexico&quot; &quot;South Dakota&quot; ... ## $ LSAD : chr &quot;00&quot; &quot;00&quot; &quot;00&quot; &quot;00&quot; ... ## $ ALAND : num 1.99e+11 1.72e+11 3.14e+11 1.96e+11 6.77e+11 ... ## $ AWATER : num 1.37e+09 1.26e+10 7.29e+08 3.38e+09 1.90e+10 ... ## $ geometry :sfc_MULTIPOLYGON of length 48; first list element: List of 1 ## ..$ :List of 1 ## .. ..$ : num [1:1516, 1:2] -104 -104 -104 -104 -104 ... ## ..- attr(*, &quot;class&quot;)= chr [1:3] &quot;XY&quot; &quot;MULTIPOLYGON&quot; &quot;sfg&quot; ## $ WaterArea_km2: num 1.372 12.559 0.729 3.383 19.006 ... ## $ WaterArea_cut: Factor w/ 5 levels &quot;[0.489,1.38]&quot;,..: 1 5 1 3 5 5 2 4 3 3 ... ## - attr(*, &quot;sf_column&quot;)= chr &quot;geometry&quot; ## - attr(*, &quot;agr&quot;)= Factor w/ 3 levels &quot;constant&quot;,&quot;aggregate&quot;,..: NA NA NA NA NA NA NA NA NA NA ... ## ..- attr(*, &quot;names&quot;)= chr [1:11] &quot;STATEFP&quot; &quot;STATENS&quot; &quot;AFFGEOID&quot; &quot;GEOID&quot; ... Essentially you added a new factor variable called WaterArea_cut with five levels corresponding to equal number of water area values. You can go directly to the mapping as follows. ggplot(data = usa_48.sf) + geom_sf(aes(fill = WaterArea_cut)) Make a choropleth map displaying the ratio of water area to land area (ALAND) by state. ggplot(data = usa_48.sf) + geom_sf(aes(fill = AWATER/ALAND * 100)) Overlays The usa_48.sf simple feature data frame uses longitude and latitude for it’s coordinate reference system (CRS). All spatial data frames have a CRS. To see what CRS a simple feature data frame use the sf::st_crs() function. sf::st_crs(usa_48.sf) ## Coordinate Reference System: ## User input: NAD83 ## wkt: ## GEOGCRS[&quot;NAD83&quot;, ## DATUM[&quot;North American Datum 1983&quot;, ## ELLIPSOID[&quot;GRS 1980&quot;,6378137,298.257222101, ## LENGTHUNIT[&quot;metre&quot;,1]]], ## PRIMEM[&quot;Greenwich&quot;,0, ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], ## CS[ellipsoidal,2], ## AXIS[&quot;latitude&quot;,north, ## ORDER[1], ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], ## AXIS[&quot;longitude&quot;,east, ## ORDER[2], ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], ## ID[&quot;EPSG&quot;,4269]] The Coordinate Reference System information including the EPSG code (4269) and the corresponding GEOGCS, DATUM, etc is given in well-known text (wkt). Here it specifies a geographic reference system with longitude and latitude and a datum (North American 1983) that describes the sea-level shape of the planet as an ellipsoid. Because the CRS uses longitude and latitude you can add locations by specifying the geographic coordinates. For example, suppose you want to overlay the locations of two cities on the map. First you create a data frame containing the longitudes, latitudes, and names of the locations. Cities.df &lt;- data.frame(long = c(-84.2809, -87.9735), lat = c(30.4381,43.0115), names = c(&quot;Tallahassee&quot;, &quot;Milwaukee&quot;)) class(Cities.df) ## [1] &quot;data.frame&quot; Next you draw the map as before but add the locations with a point layer and label the locations with a text layer. ggplot(data = usa_48.sf) + geom_sf(color = &quot;gray80&quot;) + geom_point(data = Cities.df, mapping = aes(x = long, y = lat), size = 2) + geom_text(data = Cities.df, mapping = aes(x = long, y = lat, label = names), nudge_y = 1) As another example, let’s consider the airports data frame from the {nycflights13} package. The data frame includes information on 1458 airports in the United States including their location with latitude and longitude. library(nycflights13) airports ## # A tibble: 1,458 × 8 ## faa name lat lon alt tz dst tzone ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 04G Lansdowne Airport 41.1 -80.6 1044 -5 A America/… ## 2 06A Moton Field Municipal Airport 32.5 -85.7 264 -6 A America/… ## 3 06C Schaumburg Regional 42.0 -88.1 801 -6 A America/… ## 4 06N Randall Airport 41.4 -74.4 523 -5 A America/… ## 5 09J Jekyll Island Airport 31.1 -81.4 11 -5 A America/… ## 6 0A9 Elizabethton Municipal Airport 36.4 -82.2 1593 -5 A America/… ## 7 0G6 Williams County Airport 41.5 -84.5 730 -5 A America/… ## 8 0G7 Finger Lakes Regional Airport 42.9 -76.8 492 -5 A America/… ## 9 0P2 Shoestring Aviation Airfield 39.8 -76.6 1000 -5 U America/… ## 10 0S9 Jefferson County Intl 48.1 -123. 108 -8 A America/… ## # … with 1,448 more rows Each row is an airport and the location of the airport is given in the columns lat and lon. You can make a map without boundaries by drawing a scatter plot with x = lon and y = lat. ggplot(data = airports, mapping = aes(x = lon, y = lat)) + geom_point() If you only want airports within the continental United States, you first plot the usa_48.sf boundaries and then add the airport locations as a separate point layer and the use the coord_sf() function specifying the limits of the plot in the longitude direction (xlim) and the latitude direction (ylim). ggplot(data = usa_48.sf) + geom_sf(color = &quot;gray80&quot;) + geom_point(data = airports, aes(x = lon, y = lat)) + coord_sf(xlim = c(-130, -60), ylim = c(20, 50)) + theme_minimal() Alternatively, you can use sf::st_as_sf() to convert the airports data frame to a simple features data frame. The argument coords = tells sf::st_as_sf() which columns contain the geographic coordinates of each airport. You also set the CRS using the sf::st_crs() function and use the EPSG code corresponding to a geographic CRS. airports.sf &lt;- sf::st_as_sf(airports, coords = c(&quot;lon&quot;, &quot;lat&quot;), crs = 4269) airports.sf ## Simple feature collection with 1458 features and 6 fields ## Geometry type: POINT ## Dimension: XY ## Bounding box: xmin: -176.646 ymin: 19.72137 xmax: 174.1136 ymax: 72.27083 ## Geodetic CRS: NAD83 ## # A tibble: 1,458 × 7 ## faa name alt tz dst tzone geometry ## * &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;POINT [°]&gt; ## 1 04G Lansdowne Airport 1044 -5 A Amer… (-80.61958 41.13047) ## 2 06A Moton Field Municipa… 264 -6 A Amer… (-85.68003 32.46057) ## 3 06C Schaumburg Regional 801 -6 A Amer… (-88.10124 41.98934) ## 4 06N Randall Airport 523 -5 A Amer… (-74.39156 41.43191) ## 5 09J Jekyll Island Airport 11 -5 A Amer… (-81.42778 31.07447) ## 6 0A9 Elizabethton Municip… 1593 -5 A Amer… (-82.17342 36.37122) ## 7 0G6 Williams County Airp… 730 -5 A Amer… (-84.50678 41.46731) ## 8 0G7 Finger Lakes Regiona… 492 -5 A Amer… (-76.78123 42.88356) ## 9 0P2 Shoestring Aviation … 1000 -5 U Amer… (-76.64719 39.79482) ## 10 0S9 Jefferson County Intl 108 -8 A Amer… (-122.8106 48.05381) ## # … with 1,448 more rows To graph the points on the map, you use a second geom_sf(). ggplot() + geom_sf(data = usa_48.sf) + geom_sf(data = airports.sf, shape = 1) + coord_sf(xlim = c(-130, -60), ylim = c(20, 50)) You can change the size or type of symbols on the map. For instance, you can draw a bubble plot (also known as a proportional symbol map) and encode the altitude of the airport through the size = aesthetic. ggplot() + geom_sf(data = usa_48.sf) + geom_sf(data = airports.sf, aes(size = alt), fill = &quot;grey&quot;, color = &quot;black&quot;, alpha = .2) + coord_sf(xlim = c(-130, -60), ylim = c(20, 50)) + scale_size_area(guide = FALSE) ## Warning: It is deprecated to specify `guide = FALSE` to remove a guide. Please ## use `guide = &quot;none&quot;` instead. Circle area is proportional to the airport’s altitude (in feet). Map projections Representing the globe on a flat surface is challenging. Depending on how the globe is projected onto a 2-D surface (map), at least some features will be distorted. The coord_sf() function package provides a way to project the globe in various ways. With a geographic projection the longitudes and latitudes are treated as x (horizontal) and y (vertical) coordinates. First assign the map to base_map and then render it to the plot device. base_map &lt;- ggplot(data = usa_48.sf) + geom_sf() base_map Note that the equal spacing between the latitudes and between the longitudes and that 1 degree latitude equals 1 degree longitude. To change this ‘carto-cartesian’ map you need to project it. Some projections are simple and require just the name of the projection. As an example, to change the base map to have a Mercator projection you use the coord_sf() function with crs = \"+proj=merc\". base_map + coord_sf(crs = &quot;+proj=merc&quot;) + ggtitle(&quot;Mercator projection&quot;) Note that the distance between the latitudes increases with increasing latitude. The Mercator is widely used but it makes an area closer to the poles appear larger than the same area closer to the equator. Greenland ends up larger than the entire continent of Africa. Other coordinate systems require specification of the standard lines, or lines that define areas of the surface of the map that are tangent to the globe. These include Gall-Peters, Albers equal-area, and Lambert azimuthal. base_map + coord_sf(crs = &quot;+proj=cea +lon_0=0 +lat_ts=45&quot;) + ggtitle(&quot;Gall-Peters projection&quot;) With this projection you can visually compare the areas but shapes are distorted. Distortions are minimized between latitudes defined by the Albers equal area projection. base_map + coord_sf(crs = &quot;+proj=aea +lat_1=25 +lat_2=50 +lon_0=-100&quot;) + ggtitle(&quot;Albers equal-area projection&quot;) See Kyle Walker’s get CRS See maptiles package https://github.com/riatelab/maptiles/ Why map projections matter. Clip from The West Wing. https://youtu.be/vVX-PrBRtTY "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
