[["thursday-september-22-2022.html", "Thursday, September 22, 2022 Adding data to boundary maps Changing projections Mapping using functions from tmap Making an interactive map", " Thursday, September 22, 2022 Today Adding data to boundary maps Changing projections Mapping using functions from {tmap} Making an interactive map Adding data to boundary maps Start with a boundary map. Here you import state-level census data from the shape file directory cb_2018_us_state_5m with the sf::st_read() function as a simple feature data frame with name USA.sf. USA.sf &lt;- sf::st_read(dsn = here::here(&quot;data&quot;, &quot;cb_2018_us_state_5m&quot;)) ## Reading layer `cb_2018_us_state_5m&#39; from data source ## `/Users/jameselsner/Desktop/ClassNotes/QG-2022/data/cb_2018_us_state_5m&#39; ## using driver `ESRI Shapefile&#39; ## Simple feature collection with 56 features and 9 fields ## Geometry type: MULTIPOLYGON ## Dimension: XY ## Bounding box: xmin: -179.1473 ymin: -14.55255 xmax: 179.7785 ymax: 71.35256 ## Geodetic CRS: NAD83 The print out includes information about the file. The object shows up in your environment as a data frame with 56 observations and 10 variables. Each feature is either a state or territory. Focus on the contiguous U.S. by filtering to keep only rows corresponding those states. The state.name vector object contains all 50 state names. You remove the rows corresponding to the names \"Alaska\" and \"Hawaii\". These are elements 2 and 11 so you create a new vector object called sn containing only the names of the lower 48. ( sn &lt;- state.name[c(-2, -11)] ) ## [1] &quot;Alabama&quot; &quot;Arizona&quot; &quot;Arkansas&quot; &quot;California&quot; ## [5] &quot;Colorado&quot; &quot;Connecticut&quot; &quot;Delaware&quot; &quot;Florida&quot; ## [9] &quot;Georgia&quot; &quot;Idaho&quot; &quot;Illinois&quot; &quot;Indiana&quot; ## [13] &quot;Iowa&quot; &quot;Kansas&quot; &quot;Kentucky&quot; &quot;Louisiana&quot; ## [17] &quot;Maine&quot; &quot;Maryland&quot; &quot;Massachusetts&quot; &quot;Michigan&quot; ## [21] &quot;Minnesota&quot; &quot;Mississippi&quot; &quot;Missouri&quot; &quot;Montana&quot; ## [25] &quot;Nebraska&quot; &quot;Nevada&quot; &quot;New Hampshire&quot; &quot;New Jersey&quot; ## [29] &quot;New Mexico&quot; &quot;New York&quot; &quot;North Carolina&quot; &quot;North Dakota&quot; ## [33] &quot;Ohio&quot; &quot;Oklahoma&quot; &quot;Oregon&quot; &quot;Pennsylvania&quot; ## [37] &quot;Rhode Island&quot; &quot;South Carolina&quot; &quot;South Dakota&quot; &quot;Tennessee&quot; ## [41] &quot;Texas&quot; &quot;Utah&quot; &quot;Vermont&quot; &quot;Virginia&quot; ## [45] &quot;Washington&quot; &quot;West Virginia&quot; &quot;Wisconsin&quot; &quot;Wyoming&quot; Now filter the USA.sf data frame keeping only the rows that are listed in the vector of state names. Assign this spatial data frame with name USA_48.sf. USA_48.sf &lt;- USA.sf |&gt; dplyr::filter(NAME %in% sn) Finally, draw the boundary map using the geom_sf() function with data set to the USA_48.sf simple feature data frame. library(ggplot2) ggplot(data = USA_48.sf) + geom_sf() Note: you don’t need the mapping = aes() function. The mapping is assumed from on the geometry column in the simple feature data frame. That is, the geom_sf() function maps the east-west coordinate to the x aesthetic and the north-south coordinate to the y aesthetic. Thematic (choropleth, heat) maps take data values from a column in the simple feature data frame and map them to the fill aesthetic. The fill assigns colors to the various polygon areas (e.g. countries, states, etc). For example, the column in USA_48.sf labeled AWATER contains the water area in square meters. Since the values are very large first divide by million (10^9) to get the values in 1000s of square kilometers. This is done with the dplyr::mutate() function. USA_48.sf &lt;- USA_48.sf |&gt; dplyr::mutate(WaterArea_km2 = AWATER/10^9) Then create a choropleth map showing the water area by filling the area between the state borders with a color. This is done using the mapping = aes() argument with the aes() function containing the argument fill = WaterArea_km2. ggplot(data = USA_48.sf) + geom_sf(mapping = aes(fill = WaterArea_km2)) Note how this differs from just drawing the boundaries. In this case you use the aes() function with the fill = aesthetic. The map is not very informative. large water area of Michigan which includes Lakes Michigan, Superior, and Huron has by far the most water area with most other states have a lot less. To change the range on the fill aesthetic here you use the logarithm of the area. The base 10 logarithm is 0 when the value is 1, 1 when the value is 10, 2 when the value is 100 and so on. This is seen with the log10() function. log10(c(1, 10, 100, 1000, 10000)) ## [1] 0 1 2 3 4 You convert the area to logarithms with the log10() function inside the aes() function as follows. ggplot(data = USA_48.sf) + geom_sf(mapping = aes(fill = log10(WaterArea_km2))) Another way to make the map more informative is to convert the continuous variable to a discrete variable. In the {dplyr} package the dplyr::cut_interval() function takes a continuous variable and makes n groups each having an equal range, dplyr::cut_number() makes n groups with (approximately) equal numbers of observations; dplyr::cut_width() makes groups of equal width. As an example, if you want a map with 5 colors with each color representing a state having a similar amount of water area you would use cut_number() and specify n = 5. You do this with the dplyr::mutate() function to create a new variable (column) called WaterArea_cut. USA_48.sf &lt;- USA_48.sf |&gt; dplyr::mutate(WaterArea_cut = cut_number(WaterArea_km2, n = 5)) str(USA_48.sf) ## Classes &#39;sf&#39; and &#39;data.frame&#39;: 48 obs. of 12 variables: ## $ STATEFP : chr &quot;31&quot; &quot;53&quot; &quot;35&quot; &quot;46&quot; ... ## $ STATENS : chr &quot;01779792&quot; &quot;01779804&quot; &quot;00897535&quot; &quot;01785534&quot; ... ## $ AFFGEOID : chr &quot;0400000US31&quot; &quot;0400000US53&quot; &quot;0400000US35&quot; &quot;0400000US46&quot; ... ## $ GEOID : chr &quot;31&quot; &quot;53&quot; &quot;35&quot; &quot;46&quot; ... ## $ STUSPS : chr &quot;NE&quot; &quot;WA&quot; &quot;NM&quot; &quot;SD&quot; ... ## $ NAME : chr &quot;Nebraska&quot; &quot;Washington&quot; &quot;New Mexico&quot; &quot;South Dakota&quot; ... ## $ LSAD : chr &quot;00&quot; &quot;00&quot; &quot;00&quot; &quot;00&quot; ... ## $ ALAND : num 1.99e+11 1.72e+11 3.14e+11 1.96e+11 6.77e+11 ... ## $ AWATER : num 1.37e+09 1.26e+10 7.29e+08 3.38e+09 1.90e+10 ... ## $ geometry :sfc_MULTIPOLYGON of length 48; first list element: List of 1 ## ..$ :List of 1 ## .. ..$ : num [1:1516, 1:2] -104 -104 -104 -104 -104 ... ## ..- attr(*, &quot;class&quot;)= chr [1:3] &quot;XY&quot; &quot;MULTIPOLYGON&quot; &quot;sfg&quot; ## $ WaterArea_km2: num 1.372 12.559 0.729 3.383 19.006 ... ## $ WaterArea_cut: Factor w/ 5 levels &quot;[0.489,1.38]&quot;,..: 1 5 1 3 5 5 2 4 3 3 ... ## - attr(*, &quot;sf_column&quot;)= chr &quot;geometry&quot; ## - attr(*, &quot;agr&quot;)= Factor w/ 3 levels &quot;constant&quot;,&quot;aggregate&quot;,..: NA NA NA NA NA NA NA NA NA NA ... ## ..- attr(*, &quot;names&quot;)= chr [1:11] &quot;STATEFP&quot; &quot;STATENS&quot; &quot;AFFGEOID&quot; &quot;GEOID&quot; ... You added a new factor variable called WaterArea_cut with five levels corresponding to equal number of water area values. You go directly to the map as follows. ggplot(data = USA_48.sf) + geom_sf(mapping = aes(fill = WaterArea_cut)) Make a choropleth map displaying the ratio of water area (AWATER) to land area (ALAND) by state. ggplot(data = USA_48.sf) + geom_sf(mapping = aes(fill = AWATER/ALAND * 100)) The USA_48.sf simple feature data frame uses longitude and latitude for it’s coordinate reference system (CRS). All spatial data frames have a CRS. To see what CRS a simple feature data frame use the sf::st_crs() function. sf::st_crs(USA_48.sf) ## Coordinate Reference System: ## User input: NAD83 ## wkt: ## GEOGCRS[&quot;NAD83&quot;, ## DATUM[&quot;North American Datum 1983&quot;, ## ELLIPSOID[&quot;GRS 1980&quot;,6378137,298.257222101, ## LENGTHUNIT[&quot;metre&quot;,1]]], ## PRIMEM[&quot;Greenwich&quot;,0, ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], ## CS[ellipsoidal,2], ## AXIS[&quot;latitude&quot;,north, ## ORDER[1], ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], ## AXIS[&quot;longitude&quot;,east, ## ORDER[2], ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], ## ID[&quot;EPSG&quot;,4269]] The Coordinate Reference System information including the EPSG code (4269) and the corresponding GEOGCS, DATUM, etc is given in well-known text (wkt). Here it specifies a geographic reference system with longitude and latitude and a datum (North American 1983) that describes the sea-level shape of the planet as an ellipsoid. Because the CRS uses longitude and latitude you can add locations by specifying the geographic coordinates. For example, suppose you want to add the locations of two cities on the map. First you create a data frame containing the longitudes, latitudes, and names of the locations. Cities.df &lt;- data.frame(long = c(-84.2809, -87.9735), lat = c(30.4381,43.0115), names = c(&quot;Tallahassee&quot;, &quot;Milwaukee&quot;)) class(Cities.df) ## [1] &quot;data.frame&quot; Next you draw the map as before but add the locations with a point layer and label the locations with a text layer. ggplot(data = USA_48.sf) + geom_sf(color = &quot;gray80&quot;) + geom_point(data = Cities.df, mapping = aes(x = long, y = lat), size = 2) + geom_text(data = Cities.df, mapping = aes(x = long, y = lat, label = names), nudge_y = 1) As another example, let’s consider the airports data frame from the {nycflights13} package. The data frame includes information on 1458 airports in the United States including their location with latitude and longitude. airports &lt;- nycflights13::airports Each row is an airport and the location of the airport is given in the columns lat and lon. You can make a map without boundaries by drawing a scatter plot with x = lon and y = lat. ggplot(data = airports, mapping = aes(x = lon, y = lat)) + geom_point() If you only want airports within the continental United States, you first plot the USA_48.sf boundaries and then add the airport locations as a separate point layer and the use the coord_sf() function specifying the limits of the plot in the longitude direction (xlim) and the latitude direction (ylim). ggplot(data = USA_48.sf) + geom_sf(color = &quot;gray80&quot;) + geom_point(data = airports, mapping = aes(x = lon, y = lat)) + coord_sf(xlim = c(-130, -60), ylim = c(20, 50)) + theme_minimal() Alternatively, you can use sf::st_as_sf() to convert the airports data frame to a simple features data frame. The argument coords = tells sf::st_as_sf() which columns contain the geographic coordinates of each airport. You also set the CRS using the sf::st_crs() function and use the EPSG code corresponding to a geographic CRS. ( airports.sf &lt;- sf::st_as_sf(airports, coords = c(&quot;lon&quot;, &quot;lat&quot;), crs = 4269) ) ## Simple feature collection with 1458 features and 6 fields ## Geometry type: POINT ## Dimension: XY ## Bounding box: xmin: -176.646 ymin: 19.72137 xmax: 174.1136 ymax: 72.27083 ## Geodetic CRS: NAD83 ## # A tibble: 1,458 × 7 ## faa name alt tz dst tzone geometry ## * &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;POINT [°]&gt; ## 1 04G Lansdowne Airport 1044 -5 A Amer… (-80.61958 41.13047) ## 2 06A Moton Field Municipa… 264 -6 A Amer… (-85.68003 32.46057) ## 3 06C Schaumburg Regional 801 -6 A Amer… (-88.10124 41.98934) ## 4 06N Randall Airport 523 -5 A Amer… (-74.39156 41.43191) ## 5 09J Jekyll Island Airport 11 -5 A Amer… (-81.42778 31.07447) ## 6 0A9 Elizabethton Municip… 1593 -5 A Amer… (-82.17342 36.37122) ## 7 0G6 Williams County Airp… 730 -5 A Amer… (-84.50678 41.46731) ## 8 0G7 Finger Lakes Regiona… 492 -5 A Amer… (-76.78123 42.88356) ## 9 0P2 Shoestring Aviation … 1000 -5 U Amer… (-76.64719 39.79482) ## 10 0S9 Jefferson County Intl 108 -8 A Amer… (-122.8106 48.05381) ## # … with 1,448 more rows ## # ℹ Use `print(n = ...)` to see more rows To graph the points on the map, you use a second geom_sf(). ggplot() + geom_sf(data = USA_48.sf) + geom_sf(data = airports.sf, shape = 1) + coord_sf(xlim = c(-130, -60), ylim = c(20, 50)) You can change the size or type of symbols on the map. For instance, you can draw a bubble plot (also known as a proportional symbol map) and encode the altitude of the airport through the size = aesthetic. ggplot() + geom_sf(data = USA_48.sf) + geom_sf(data = airports.sf, mapping = aes(size = alt), fill = &quot;grey&quot;, color = &quot;black&quot;, alpha = .2) + coord_sf(xlim = c(-130, -60), ylim = c(20, 50)) + scale_size_area(guide = &quot;none&quot;) Circle area is proportional to the airport’s altitude (in feet). Changing projections With a geographic projection the longitudes and latitudes are treated as x (horizontal) and y (vertical) coordinates. Consider again the boundary map of the lower 48 states. Here you get the boundary file using the USAboundaries::us_states() function and use the filter() function to remove rows corresponding to Hawaii, Alaska, and Puerto Rico. USA_48.sf &lt;- USAboundaries::us_states() |&gt; dplyr::filter(!state_name %in% c(&quot;Hawaii&quot;, &quot;Alaska&quot;, &quot;Puerto Rico&quot;)) Geometry calculations should be done on projected coordinates. To see what CRS the simple feature data frame has use st_crs(). sf::st_crs(USA_48.sf) ## Coordinate Reference System: ## User input: EPSG:4326 ## wkt: ## GEOGCRS[&quot;WGS 84&quot;, ## DATUM[&quot;World Geodetic System 1984&quot;, ## ELLIPSOID[&quot;WGS 84&quot;,6378137,298.257223563, ## LENGTHUNIT[&quot;metre&quot;,1]]], ## PRIMEM[&quot;Greenwich&quot;,0, ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], ## CS[ellipsoidal,2], ## AXIS[&quot;geodetic latitude (Lat)&quot;,north, ## ORDER[1], ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], ## AXIS[&quot;geodetic longitude (Lon)&quot;,east, ## ORDER[2], ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], ## USAGE[ ## SCOPE[&quot;Horizontal component of 3D system.&quot;], ## AREA[&quot;World.&quot;], ## BBOX[-90,-180,90,180]], ## ID[&quot;EPSG&quot;,4326]] Here you first assign the map to an object called base_map and then render the map to the plot device. ( base_map &lt;- ggplot(data = USA_48.sf) + geom_sf() ) Note the length unit (LENGTHUNIT[]) is meter. sf::st_crs(USA_48.sf) ## Coordinate Reference System: ## User input: EPSG:4326 ## wkt: ## GEOGCRS[&quot;WGS 84&quot;, ## DATUM[&quot;World Geodetic System 1984&quot;, ## ELLIPSOID[&quot;WGS 84&quot;,6378137,298.257223563, ## LENGTHUNIT[&quot;metre&quot;,1]]], ## PRIMEM[&quot;Greenwich&quot;,0, ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], ## CS[ellipsoidal,2], ## AXIS[&quot;geodetic latitude (Lat)&quot;,north, ## ORDER[1], ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], ## AXIS[&quot;geodetic longitude (Lon)&quot;,east, ## ORDER[2], ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], ## USAGE[ ## SCOPE[&quot;Horizontal component of 3D system.&quot;], ## AREA[&quot;World.&quot;], ## BBOX[-90,-180,90,180]], ## ID[&quot;EPSG&quot;,4326]] You change the projection by specifying the CRS. For example to change the base map to have a Mercator projection you use the coord_sf() function with crs = 3857, which uses the EPSG code 3857 for world Mercator projection. base_map + coord_sf(crs = 3857) + ggtitle(&quot;Mercator projection&quot;) Other coordinate systems require specification of the standard lines, or lines that define areas of the surface of the map that are tangent to the globe. These include Gall-Peters, Albers equal-area, and Lambert azimuthal. These can be specified with the proj.4 definitions which are implemented using character strings. For example the Gall-Peters projection uses the character string \"+proj=cea +lon_0=0 +lat_ts=45\". Here you use the sf::st_transform() function to change the projection in the geometry column of USA_48.sf. USA_48.sf |&gt; sf::st_transform(crs = &quot;+proj=cea +lon_0=0 +lat_ts=45&quot;) |&gt; ggplot() + geom_sf() + ggtitle(&quot;Gall-Peters projection&quot;) Distortions are smallest between latitudes defined by the Albers equal-area projection. USA_48.sf |&gt; sf::st_transform(crs = &quot;+proj=aea +lat_1=25 +lat_2=50 +lon_0=-100&quot;) |&gt; ggplot() + geom_sf() + ggtitle(&quot;Albers equal-area projection&quot;) The crsuggest::suggest_crs() function gives suggested planar projected CRS’s for your simple feature data frame. crsuggest::suggest_crs(USA_48.sf) ## # A tibble: 10 × 6 ## crs_code crs_name crs_t…¹ crs_gcs crs_u…² crs_p…³ ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 6350 NAD83(2011) / Conus Albers projec… 6318 m +proj=… ## 2 5072 NAD83(NSRS2007) / Conus Albers projec… 4759 m +proj=… ## 3 5071 NAD83(HARN) / Conus Albers projec… 4152 m +proj=… ## 4 5070 NAD83 / Conus Albers projec… 4269 m +proj=… ## 5 5069 NAD27 / Conus Albers projec… 4267 m +proj=… ## 6 6501 NAD83(2011) / Minnesota Central (ft… projec… 6318 us-ft +proj=… ## 7 6500 NAD83(2011) / Minnesota Central projec… 6318 m +proj=… ## 8 3594 NAD83(NSRS2007) / Minnesota Central projec… 4759 m +proj=… ## 9 2811 NAD83(HARN) / Minnesota Central projec… 4152 m +proj=… ## 10 26992 NAD83 / Minnesota Central projec… 4269 m +proj=… ## # … with abbreviated variable names ¹​crs_type, ²​crs_units, ³​crs_proj4 USA_48.sf |&gt; sf::st_transform(crs = 6350) |&gt; ggplot() + geom_sf() + ggtitle(&quot;Conus Albers&quot;) Mapping using functions from tmap There are several other packages for making quick, nice maps. I particularly like the {tmap} package because it is agnostic to the type of spatial data object. Simple feature data frames as well as {sp} and {terra} objects can be combined on a single map. This is not the case with the ggplot2::geom_sf() function which only accepts simple feature data frames. if(!require(tmap)) install.packages(pkgs = &quot;tmap&quot;, repos = &quot;http://cran.us.r-project.org&quot;) ## Loading required package: tmap Functions in the {tmap} use the ‘grammar of graphics’ philosophy that separates the data frame from the aesthetics (how data are made visible). Functions translate the data into aesthetics. The aesthetics can include the location on a geographic map (defined by the geometry), color, and other visual components. A map made with functions from {tmap} starts with the tmap::tm_shape() function that takes as input a spatial data frame. The function is followed by one or more layers such as tmap::tm_fill(), tmap::tm_dots(), tmap::tm_raster(), etc that defines how a property in the data gets translated to a visual component. Consider the simple feature data frame spData::nz containing polygons representing the 16 regions of New Zealand (2018). See https://en.wikipedia.org/wiki/Regions_of_New_Zealand for a description of these regions and https://www.stats.govt.nz for information on the data source. To make a map of the region borders you first identify the spatial data frame with the tmap::tm_shape() function and then add a borders layer with the tmap::tm_borders() layer. tmap::tm_shape(shp = spData::nz) + tmap::tm_borders() The function tmap::tm_shape() and its subsequent drawing layers (here tmap::tm_borders()) as a ‘group’. The data in the tmap::tm_shape() function must be a spatial object of class simple feature, raster, or an S4 class spatial object. Compare with the {ggplot2} syntax. ggplot(data = spData::nz) + geom_sf() With {ggplot2} you use the mapping = aes() argument to specify how to handle the non-geometric aesthetics. With the {tmap} you use a different function. For example, here you use a fill layer (tmap::tm_fill()) instead of the borders layer. tmap::tm_shape(spData::nz) + tmap::tm_fill() The polygons defining the boundaries are filled using the same gray color (default) as the borders so they disappear. Here you first add the fill layer and then add a border layer. tmap::tm_shape(spData::nz) + tmap::tm_fill(col = &#39;green&#39;) + tmap::tm_borders() Layers are added with the + operator and are functionally equivalent to adding a GIS layer. You can assign the resulting map to an object. For example here you assign the map of New Zealand to the object map_nz. map_nz &lt;- tmap::tm_shape(spData::nz) + tmap::tm_polygons() class(map_nz) ## [1] &quot;tmap&quot; The resulting object is of class tmap. Additional spatial data are added to the map object with + tmap::tm_shape(new_object), where new_object is another spatial data frame the values of which are used to plot on top of the preceding layers. When a new spatial data frame is added in this way, all subsequent aesthetic functions refer to it, until another spatial data frame is added. For example, here you add an elevation layer to the New Zealand map. The elevation raster (spDataLarge::nz_elev) spatial data frame is in the {spDataLarge} package on GitHub. The install_github() function from the {devtools} package is used to install packages on GitHub. GitHub is a company that provides hosting for software development version control using Git. Git is a version-control system for tracking changes in code during software development. if(!require(devtools)) install.packages(pkgs = &quot;devtools&quot;, repos = &quot;http://cran.us.r-project.org&quot;) ## Loading required package: devtools ## Loading required package: usethis library(devtools) if(!require(spDataLarge)) install_github(repo = &quot;Nowosad/spDataLarge&quot;) ## Loading required package: spDataLarge library(spDataLarge) Next you identify the spatial data for the the new layer by adding tmap::tm_shape(nz_elev). Then add the raster layer with the tmap::tm_raster() function and set the transparency level to 70% (alpha = .7). ( map_nz1 &lt;- map_nz + tmap::tm_shape(shp = spDataLarge::nz_elev) + tmap::tm_raster(alpha = .7) ) ## stars object downsampled to 877 by 1140 cells. See tm_shape manual (argument raster.downsample) You can see that the new map object, that you assign to map_nz1, builds on top of the existing map object map_nz by adding the raster layer spDataLarge::nz_elev representing elevation. You can also create new layers with functions. For instance, a function like sf::st_union() operates on the geometry column of a simple feature data frame. As an example, here you create a line string layer as a simple feature object using three geo-computation functions. You start by creating a union over all polygons (regions) with the sf::st_union() function applied to the spData::nz simple feature object. The result is a polygon defining the coastlines. Then you buffer this polygon out to a distance of 22.2 km using the sf::st_buffer() function. The result is a single polygon defining the coastal boundary around the entire country. Finally you change the polygon geometry to a line string geometry with the sf::st_cast() function. To keep your code human-readable, you link these operations together with the pipe operator as follows. ( nz_water.sfc &lt;- spData::nz |&gt; sf::st_union() |&gt; sf::st_buffer(dist = 22200) |&gt; sf::st_cast(to = &quot;LINESTRING&quot;) ) ## Geometry set for 1 feature ## Geometry type: LINESTRING ## Dimension: XY ## Bounding box: xmin: 1067944 ymin: 4726340 xmax: 2111732 ymax: 6214066 ## Projected CRS: NZGD2000 / New Zealand Transverse Mercator 2000 ## LINESTRING (1074909 4920220, 1074855 4920397, 1... The result is simple feature column. You then add the resulting sfc as a layer to the map. ( map_nz2 &lt;- map_nz1 + tmap::tm_shape(shp = nz_water.sfc) + tmap::tm_lines() ) ## stars object downsampled to 877 by 1140 cells. See tm_shape manual (argument raster.downsample) Finally, you create a layer representing the country elevation high points (stored in the object spData::nz_height) onto the map_nz2 object with tmap::tm_dots() function. ( map_nz3 &lt;- map_nz2 + tmap::tm_shape(shp = spData::nz_height) + tmap::tm_dots() ) ## stars object downsampled to 877 by 1140 cells. See tm_shape manual (argument raster.downsample) Layout functions help create a cartographic map. Elements include the title, the scale bar, margins, aspect ratios, etc. For example, here elements such as a north arrow and a scale bar are added with tmap::tm_compass() and tmap::tm_scale_bar(), respectively and the tmap::tm_layout() function is used to add the title and background color. map_nz + tmap::tm_compass(type = &quot;8star&quot;, position = c(&quot;left&quot;, &quot;top&quot;)) + tmap::tm_scale_bar(breaks = c(0, 100, 200), text.size = 1) + tmap::tm_layout(title = &quot;New Zealand&quot;, bg.color = &quot;lightblue&quot;) Putting two or more maps with the same scale side by side allows for comparisons. You can see how spatial relationships change with respect to another variable. Creating small multiples of the same map with different variables is called ‘faceting’. Consider the simple feature data frame World. Make the data frame accessible to this session with the data() function. library(tmap) data(World) head(World) ## Simple feature collection with 6 features and 15 fields ## Geometry type: MULTIPOLYGON ## Dimension: XY ## Bounding box: xmin: -73.41544 ymin: -55.25 xmax: 75.15803 ymax: 42.68825 ## Geodetic CRS: WGS 84 ## iso_a3 name sovereignt continent ## 1 AFG Afghanistan Afghanistan Asia ## 2 AGO Angola Angola Africa ## 3 ALB Albania Albania Europe ## 4 ARE United Arab Emirates United Arab Emirates Asia ## 5 ARG Argentina Argentina South America ## 6 ARM Armenia Armenia Asia ## area pop_est pop_est_dens economy ## 1 652860.00 [km^2] 28400000 43.50090 7. Least developed region ## 2 1246700.00 [km^2] 12799293 10.26654 7. Least developed region ## 3 27400.00 [km^2] 3639453 132.82675 6. Developing region ## 4 71252.17 [km^2] 4798491 67.34519 6. Developing region ## 5 2736690.00 [km^2] 40913584 14.95003 5. Emerging region: G20 ## 6 28470.00 [km^2] 2967004 104.21510 6. Developing region ## income_grp gdp_cap_est life_exp well_being footprint inequality ## 1 5. Low income 784.1549 59.668 3.8 0.79 0.4265574 ## 2 3. Upper middle income 8617.6635 NA NA NA NA ## 3 4. Lower middle income 5992.6588 77.347 5.5 2.21 0.1651337 ## 4 2. High income: nonOECD 38407.9078 NA NA NA NA ## 5 3. Upper middle income 14027.1261 75.927 6.5 3.14 0.1642383 ## 6 4. Lower middle income 6326.2469 74.446 4.3 2.23 0.2166481 ## HPI geometry ## 1 20.22535 MULTIPOLYGON (((61.21082 35... ## 2 NA MULTIPOLYGON (((16.32653 -5... ## 3 36.76687 MULTIPOLYGON (((20.59025 41... ## 4 NA MULTIPOLYGON (((51.57952 24... ## 5 35.19024 MULTIPOLYGON (((-65.5 -55.2... ## 6 25.66642 MULTIPOLYGON (((43.58275 41... The simple feature data frame has socio-economic indicators by country. Each row is a country. Further, consider the simple feature data frame spData::urban_agglomerations. The data frame is from the United Nations population division with projections up to 2050 for the top 30 largest areas by population at 5 year intervals (in long form). The geometries are points indicating the location of the largest urban metro areas. You create a new data frame keeping only the years 1970, 1990, 2010, and 2030 by using the dplyr::filter() function. urb_1970_2030 &lt;- spData::urban_agglomerations |&gt; dplyr::filter(year %in% c(1970, 1990, 2010, 2030)) Again, the operator %in% acts like a recursive or. If year == 1970 or year == 1990, … For example, The first map layer is the country polygons from the World data frame and the second layer is city locations from the urb_1970_2030 data frame using the tmap::tm_symbols() function. Symbol size is scaled by the variable population_millions. Finally you group by the variable year with the tmap::tm_facets() function to produce a four-panel set of maps. tmap::tm_shape(World) + tmap::tm_polygons() + tmap::tm_shape(urb_1970_2030) + tmap::tm_symbols(col = &quot;black&quot;, border.col = &quot;white&quot;, size = &quot;population_millions&quot;) + tmap::tm_facets(by = &quot;year&quot;, nrow = 2, free.coords = FALSE) The above code chunk demonstrates key features of faceted maps created with functions from the {tmap} package. Shapes that do not have a facet variable are repeated (the countries in World in this case). The by = argument which varies depending on a variable (year in this case). nrow/ncol setting specifying the number of rows (and columns) that facets should be arranged into. The free.coords = argument specifies whether each map has its own bounding box. Small multiples are also generated by assigning more than one value to an aesthetic arguments. For example here you map the happiness index (HPI) on one map and gross domestic product per person (gdp_cap_est) on another map. Both variables are in the World data frame. tmap::tm_shape(shp = World) + tmap::tm_polygons(col = c(&quot;HPI&quot;, &quot;gdp_cap_est&quot;), style = c(&quot;pretty&quot;, &quot;kmeans&quot;), palette = list(&quot;RdYlGn&quot;, &quot;Purples&quot;), title = c(&quot;Happy Planet Index&quot;, &quot;GDP per capita&quot;)) Note that the variable names must be in quotes (e.g., “HPI”). This is different than variables named in the {ggplot2} functions. The maps are identical except for the variable being plotted. All arguments of the layer functions can be vectorized, one for each map. Arguments that normally take a vector, such as palette =, are placed in a list(). Multiple map objects can also be arranged in a single plot with the tmap::tmap_arrange() function. Here you create two separate maps then arrange them. map1 &lt;- tmap::tm_shape(World) + tmap::tm_polygons(col = &quot;HPI&quot;, style = &quot;pretty&quot;, palette = &quot;RdYlGn&quot;, title = &quot;Happy Planet Index&quot;) map2 &lt;- tmap::tm_shape(World) + tmap::tm_polygons(col = &quot;gdp_cap_est&quot;, style = &quot;kmeans&quot;, palette = &quot;Purples&quot;, title = &quot;GDP per capita&quot;) tmap::tmap_arrange(map1, map2) Making an interactive map A nice feature of the {tmap} package is that you can create an interactive map using the same code used to create a static map. Consider again the boundary map of the contiguous 48 states. tmap::tm_shape(USA_48.sf) + tmap::tm_borders() By default the map gets rendered directly to the Rmd screen or to the Plots window as a static image. To change the default to an interactive image you set the render mode to \"view\" in the tmap::tmap_mode() function. Here you repeat the county boundary map after specifying the render mode. tmap::tmap_mode(&quot;view&quot;) ## tmap mode set to interactive viewing tmap::tm_shape(USA_48.sf) + tmap::tm_borders() The county borders from your spatial data frame are overlaid on zoom-able Leaflet tiles. You can change the underlying layers by clicking on the layering symbol. You can also create interactive maps with the tmap::tmap_leaflet() function. The view mode in {tmap} also works with faceted plots. The argument sync in tmap::tm_facets() is used to produce multiple maps with synchronized zoom and pan settings. Change the view mode back to a static plot. tmap::tmap_mode(&quot;plot&quot;) ## tmap mode set to plotting Additional information Why map projections matter https://youtu.be/vVX-PrBRtTY Bivariate maps. See Other_Rmds/BivariateMaps.Rmd See the {maptiles} package https://github.com/riatelab/maptiles/ Getting started with {tmap} https://cran.r-project.org/web/packages/tmap/vignettes/tmap-getstarted.html "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
