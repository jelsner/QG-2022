# Thursday, September 22, 2022 {.unnumbered}

Today

-   Adding data to boundary maps
-   Changing map projections
-   Making maps using functions from {tmap}
-   Making a map interactive

## Adding data to boundary maps {.unnumbered}

Start with a boundary map. Here you import state-level census data from the shape file directory `cb_2018_us_state_5m` with the `sf::st_read()` function as a simple feature data frame with name `USA.sf`.

```{r}
USA.sf <- sf::st_read(dsn = here::here("data", "cb_2018_us_state_5m"))
```

The output includes information about the file. The object shows up in your environment as a data frame with 56 observations and 10 variables. Each feature is either a state or territory.

Focus on the contiguous U.S. by filtering to keep only rows corresponding those states. The `state.name` vector object contains all 50 state names. You remove the rows corresponding to the names `"Alaska"` and `"Hawaii"`. These are elements 2 and 11 so you create a new vector object called `sn` containing only the names of the lower 48.

```{r}
( sn <- state.name[c(-2, -11)] )
```

Now filter the `USA.sf` data frame keeping only the rows that are listed in the vector of state names. Assign this spatial data frame with name `USA_48.sf`.

```{r}
USA_48.sf <- USA.sf |>
  dplyr::filter(NAME %in% sn)
```

Finally, draw the boundary map using the `geom_sf()` function with data set to the `USA_48.sf` simple feature data frame.

```{r}
library(ggplot2)

ggplot(data = USA_48.sf) +
  geom_sf()
```

Note: you don't need the `mapping = aes()` function. The mapping is assumed from on the `geometry` column in the simple feature data frame. That is, the `geom_sf()` function maps the east-west coordinate to the `x` aesthetic and the north-south coordinate to the `y` aesthetic.

Thematic (choropleth, heat) maps take data values from a column in the simple feature data frame and map them to the `fill` aesthetic. The fill assigns colors to the various polygon areas (e.g. countries, states, etc).

For example, the column in `USA_48.sf` labeled `AWATER` contains the water area in square meters. Since the values are very large first divide by million (10\^9) to get the values in 1000s of square kilometers. This is done with the `dplyr::mutate()` function.

```{r}
USA_48.sf <- USA_48.sf |>
  dplyr::mutate(WaterArea_km2 = AWATER/10^9)
```

Then create a choropleth map showing the water area by filling the area between the state borders with a color. This is done using the `mapping = aes()` argument with the `aes()` function containing the argument `fill = WaterArea_km2`.

```{r}
ggplot(data = USA_48.sf) +
  geom_sf(mapping = aes(fill = WaterArea_km2))
```

Note how this differs from just drawing the boundaries. In this case you use the `aes()` function with the `fill =` aesthetic.

The map is not very informative. large water area of Michigan which includes Lakes Michigan, Superior, and Huron has by far the most water area with most other states have a lot less.

To change the range on the fill aesthetic here you use the logarithm of the area. The base 10 logarithm is 0 when the value is 1, 1 when the value is 10, 2 when the value is 100 and so on. This is seen with the `log10()` function.

```{r}
log10(c(1, 10, 100, 1000, 10000))
```

You convert the area to logarithms with the `log10()` function inside the `aes()` function as follows.

```{r}
ggplot(data = USA_48.sf) +
  geom_sf(mapping = aes(fill = log10(WaterArea_km2))) 
```

Another way to make the map more informative is to convert the continuous variable to a discrete variable.

In the {dplyr} package the `dplyr::cut_interval()` function takes a continuous variable and makes n groups each having an equal range, `dplyr::cut_number()` makes n groups with (approximately) equal numbers of observations; `dplyr::cut_width()` makes groups of equal width.

As an example, if you want a map with 5 colors with each color representing a state having a similar amount of water area you would use `cut_number()` and specify `n = 5`. You do this with the `dplyr::mutate()` function to create a new variable (column) called `WaterArea_cut`.

```{r}
USA_48.sf <- USA_48.sf |>
  dplyr::mutate(WaterArea_cut = cut_number(WaterArea_km2, n = 5))
str(USA_48.sf)
```

You added a new factor variable called `WaterArea_cut` with five levels corresponding to equal number of water area values.

You go directly to the map as follows.

```{r}
 ggplot(data = USA_48.sf) +
    geom_sf(mapping = aes(fill = WaterArea_cut))
```

Make a choropleth map displaying the ratio of water area (`AWATER`) to land area (`ALAND`) by state.

```{r}
ggplot(data = USA_48.sf) +
  geom_sf(aes(fill = AWATER/ALAND * 100))
```

The `USA_48.sf` simple feature data frame uses longitude and latitude for it's coordinate reference system (CRS). All spatial data frames have a CRS.

To see what CRS a simple feature data frame use the `sf::st_crs()` function.

```{r}
sf::st_crs(USA_48.sf)
```

The Coordinate Reference System information including the EPSG code (4269) and the corresponding GEOGCS, DATUM, etc is given in well-known text (wkt).

Here it specifies a geographic reference system with longitude and latitude and a datum (North American 1983) that describes the sea-level shape of the planet as an ellipsoid.

Because the CRS uses longitude and latitude you can add locations by specifying the geographic coordinates.

For example, suppose you want to add the locations of two cities on the map. First you create a data frame containing the longitudes, latitudes, and names of the locations.

```{r}
Cities.df <- data.frame(long = c(-84.2809, -87.9735),
                        lat = c(30.4381,43.0115),
                        names = c("Tallahassee", "Milwaukee"))
class(Cities.df)
```

Next you draw the map as before but add the locations with a point layer and label the locations with a text layer.

```{r}
ggplot(data = USA_48.sf) +
  geom_sf(color = "gray80") +
  geom_point(data = Cities.df, 
             mapping = aes(x = long, y = lat), 
             size = 2) +
  geom_text(data = Cities.df,
            mapping = aes(x = long, y = lat, label = names),
            nudge_y = 1)
```

As another example, let's consider the `airports` data frame from the {nycflights13} package. The data frame includes information on 1458 airports in the United States including their location with latitude and longitude.

```{r}
airports <- nycflights13::airports
```

Each row is an airport and the location of the airport is given in the columns `lat` and `lon`. You can make a map without boundaries by drawing a scatter plot with `x = lon` and `y = lat`.

```{r}
ggplot(data = airports, 
       mapping = aes(x = lon, y = lat)) +
  geom_point()
```

If you only want airports within the continental United States, you first plot the `USA_48.sf` boundaries and then add the airport locations as a separate point layer and the use the `coord_sf()` function specifying the limits of the plot in the longitude direction (`xlim`) and the latitude direction (`ylim`).

```{r}
ggplot(data = USA_48.sf) + 
  geom_sf(color = "gray80") + 
  geom_point(data = airports, 
             aes(x = lon, y = lat)) +
  coord_sf(xlim = c(-130, -60),
           ylim = c(20, 50)) +
  theme_minimal()
```

Alternatively, you can use `sf::st_as_sf()` to convert the `airports` data frame to a simple features data frame. The argument `coords =` tells `sf::st_as_sf()` which columns contain the geographic coordinates of each airport. You also set the CRS using the `sf::st_crs()` function and use the EPSG code corresponding to a geographic CRS.

```{r}
( airports.sf <- sf::st_as_sf(airports, 
                              coords = c("lon", "lat"),
                              crs = 4269) )
```

To graph the points on the map, you use a second `geom_sf()`.

```{r}
ggplot() + 
  geom_sf(data = USA_48.sf) + 
  geom_sf(data = airports.sf, shape = 1) +
  coord_sf(xlim = c(-130, -60),
           ylim = c(20, 50))
```

You can change the size or type of symbols on the map. For instance, you can draw a bubble plot (also known as a proportional symbol map) and encode the altitude of the airport through the `size =` aesthetic.

```{r}
ggplot() + 
  geom_sf(data = USA_48.sf) + 
  geom_sf(data = airports.sf, aes(size = alt), 
          fill = "grey", color = "black", alpha = .2) +
  coord_sf(xlim = c(-130, -60),
           ylim = c(20, 50)) +
  scale_size_area(guide = FALSE)
```

Circle area is proportional to the airport's altitude (in feet).

## Changing map projections {.unnumbered}

With a geographic projection the longitudes and latitudes are treated as x (horizontal) and y (vertical) coordinates.

Consider again the boundary map of the lower 48 states. Here you get the boundary file using the `USAboundaries::us_states()` function and use the `filter()` function to remove rows corresponding to Hawaii, Alaska, and Puerto Rico.

```{r}
USA_48.sf <- USAboundaries::us_states() |>
   dplyr::filter(!state_name %in% c("Hawaii", "Alaska", "Puerto Rico"))
```

Geometry calculations should be done on projected coordinates. To see what CRS the simple feature data frame has use `st_crs()`.

```{r}
sf::st_crs(USA_48.sf)
```

Here you first assign the map to an object called `base_map` and then render the map to the plot device.

```{r}
( base_map <- ggplot(data = USA_48.sf) +
              geom_sf() )
```

Note the length unit (`LENGTHUNIT[]`) is meter.
```{r}
sf::st_crs(USA_48.sf)
```

You change the projection by specifying the CRS. For example to change the base map to have a Mercator projection you use the `coord_sf()` function with `crs = 3857`, which uses the EPSG code 3857 for world Mercator projection.

```{r}
base_map +
  coord_sf(crs = 3857) +
  ggtitle("Mercator projection")
```

Other coordinate systems require specification of the standard lines, or lines that define areas of the surface of the map that are tangent to the globe. These include Gall-Peters, Albers equal-area, and Lambert azimuthal. These can be specified with the proj.4 definitions which are implemented using character strings.

For example the Gall-Peters projection uses the character string `"+proj=cea +lon_0=0 +lat_ts=45"`. Here you use the `sf::st_transform()` function to change the projection in the geometry column of `USA_48.sf`.

```{r}
USA_48.sf |>
  sf::st_transform(crs = "+proj=cea +lon_0=0 +lat_ts=45") |>
  ggplot() +
  geom_sf() +
  ggtitle("Gall-Peters projection")
```

Distortions are smallest between latitudes defined by the Albers equal-area projection.

```{r}
USA_48.sf |>
  sf::st_transform(crs = "+proj=aea +lat_1=25 +lat_2=50 +lon_0=-100") |>
  ggplot() +
  geom_sf() +
  ggtitle("Albers equal-area projection")
```

The `crsuggest::suggest_crs()` function gives suggested planar projected CRS's for your simple feature data frame.

```{r}
crsuggest::suggest_crs(USA_48.sf)
```

```{r}
USA_48.sf |>
  sf::st_transform(crs = 6350) |>
  ggplot() +
  geom_sf() +
  ggtitle("Conus Albers")
```

## Mapping using functions from tmap {.unnumbered}

There are several other packages for making quick, nice maps. I particularly like the {tmap} package because it is agnostic to the type of spatial data object. Simple feature data frames as well as {sp} and {terra} objects can be combined on a single map. This is not the case with the `ggplot2::geom_sf()` function which only accepts simple feature data frames.

```{r}
if(!require(tmap)) install.packages(pkgs = "tmap", repos = "http://cran.us.r-project.org")
```

Functions in the {tmap} use the 'grammar of graphics' philosophy that separates the data frame from the aesthetics (how data are made visible). Functions translate the data into aesthetics. The aesthetics can include the location on a geographic map (defined by the geometry), color, and other visual components.

A map made with functions from {tmap} starts with the `tmap::tm_shape()` function that takes as input a spatial data frame. The function is followed by one or more layers such as `tmap::tm_fill()`, `tmap::tm_dots()`, `tmap::tm_raster()`, etc that defines how a property in the data gets translated to a visual component.

Consider the simple feature data frame `spData::nz` containing polygons representing the 16 regions of New Zealand (2018). See https://en.wikipedia.org/wiki/Regions_of_New_Zealand for a description of these regions and https://www.stats.govt.nz for information on the data source.

To make a map of the region borders you first identify the spatial data frame with the `tmap::tm_shape()` function and then add a borders layer with the `tmap::tm_borders()` layer.

```{r}
tmap::tm_shape(shp = spData::nz) +
  tmap::tm_borders() 
```

The function `tmap::tm_shape()` and its subsequent drawing layers (here `tmap::tm_borders()`) as a 'group'. The data in the `tmap::tm_shape()` function must be a spatial object of class simple feature, raster, or an S4 class spatial object.

Compare with the {ggplot2} syntax.

```{r}
ggplot(data = spData::nz) +
  geom_sf()
```

With {ggplot2} you use the `mapping = aes()` argument to specify how to handle the non-geometric aesthetics. With the {tmap} you use a different function.

For example, here you use a fill layer (`tmap::tm_fill()`) instead of the borders layer.

```{r}
tmap::tm_shape(spData::nz) +
  tmap::tm_fill() 
```

The polygons defining the boundaries are filled using the same gray color (default) as the borders so they disappear.

Here you first add the fill layer and then add a border layer.

```{r}
tmap::tm_shape(spData::nz) +
  tmap::tm_fill(col = 'green') +
  tmap::tm_borders() 
```

Layers are added with the `+` operator and are functionally equivalent to adding a GIS layer.

You can assign the resulting map to an object. For example here you assign the map of New Zealand to the object `map_nz`.

```{r}
map_nz <- tmap::tm_shape(spData::nz) + 
  tmap::tm_polygons()

class(map_nz)
```

The resulting object is of class `tmap`.

Additional spatial data are added to the map object with `+ tmap::tm_shape(new_object)`, where `new_object` is another spatial data frame the values of which are used to plot on top of the preceding layers.

When a new spatial data frame is added in this way, all subsequent aesthetic functions refer to it, until another spatial data frame is added.

For example, here you add an elevation layer to the New Zealand map. The elevation raster (`spDataLarge::nz_elev`) spatial data frame is in the {spDataLarge} package on GitHub.

The `install_github()` function from the {devtools} package is used to install packages on GitHub. GitHub is a company that provides hosting for software development version control using Git. Git is a version-control system for tracking changes in code during software development.

```{r}
if(!require(devtools)) install.packages(pkgs = "devtools", repos = "http://cran.us.r-project.org")
library(devtools)

if(!require(spDataLarge)) install_github(repo = "Nowosad/spDataLarge")
library(spDataLarge)
```

Next you identify the spatial data for the the new layer by adding `tmap::tm_shape(nz_elev)`. Then add the raster layer with the `tmap::tm_raster()` function and set the transparency level to 70% (`alpha = .7`).

```{r}
( map_nz1 <- map_nz +
  tmap::tm_shape(spDataLarge::nz_elev) + 
    tmap::tm_raster(alpha = .7) )
```

You can see that the new map object, that you assign to `map_nz1`, builds on top of the existing map object `map_nz` by adding the raster layer `spDataLarge::nz_elev` representing elevation.

You can also create new layers with functions. For instance, a function like `sf::st_union()` operates on the `geometry` column of a simple feature data frame.

As an example, here you create a line string layer as a simple feature object using three geo-computation functions. You start by creating a union over all polygons (regions) with the `sf::st_union()` function applied to the `spData::nz` simple feature object. The result is a polygon defining the coastlines.

Then you buffer this polygon out to a distance of 22.2 km using the `sf::st_buffer()` function. The result is a single polygon defining the coastal boundary around the entire country.

Finally you change the polygon geometry to a line string geometry with the `sf::st_cast()` function.

To keep your code human-readable, you link these operations together with the pipe operator as follows.

```{r}
( nz_water.sfc <- spData::nz |>
  sf::st_union() |> 
  sf::st_buffer(dist = 22200) |> 
  sf::st_cast(to = "LINESTRING") )
```

The result is simple feature column. You then add the resulting `sfc` as a layer to the map.

```{r}
( map_nz2 <- map_nz1 +
  tmap::tm_shape(nz_water.sfc) + 
    tmap::tm_lines() )
```

Finally, you create a layer representing the country elevation high points (stored in the object `spData::nz_height`) onto the `map_nz2` object with `tmap::tm_dots()` function.

```{r}
( map_nz3 <- map_nz2 +
  tmap::tm_shape(spData::nz_height) + 
    tmap::tm_dots() )
```

Layout functions help create a cartographic map. Elements include the title, the scale bar, margins, aspect ratios, etc. For example, here elements such as a north arrow and a scale bar are added with `tmap::tm_compass()` and `tmap::tm_scale_bar()`, respectively and the `tmap::tm_layout()` function is used to add the title and background color.

```{r}
map_nz + 
  tmap::tm_compass(type = "8star", 
                   position = c("left", "top")) +
  tmap::tm_scale_bar(breaks = c(0, 100, 200), 
                     text.size = 1) +
  tmap::tm_layout(title = "New Zealand",
                  bg.color = "lightblue")
```

Putting two or more maps with the same scale side by side allows for comparisons. You can see how spatial relationships change with respect to another variable.

Creating small multiples of the same map with different variables is called 'faceting'.

Consider the simple feature data frame `World`. Make the data frame accessible to this session with the `data()` function.

```{r}
library(tmap)

data(World)
head(World)
```

The simple feature data frame has socio-economic indicators by country. Each row is a country.

Further, consider the simple feature data frame `spData::urban_agglomerations`. The data frame is from the United Nations population division with projections up to 2050 for the top 30 largest areas by population at 5 year intervals (in long form).

The geometries are points indicating the location of the largest urban metro areas.

You create a new data frame keeping only the years 1970, 1990, 2010, and 2030 by using the `dplyr::filter()` function.

```{r}
urb_1970_2030 <- spData::urban_agglomerations |> 
  dplyr::filter(year %in% c(1970, 1990, 2010, 2030))
```

Again, the operator `%in%` acts like a recursive `or`. If year == 1970 or year == 1990, ... For example,

The first map layer is the country polygons from the `World` data frame and the second layer is city locations from the `urb_1970_2030` data frame using the `tmap::tm_symbols()` function.

Symbol size is scaled by the variable `population_millions`. Finally you group by the variable `year` with the `tmap::tm_facets()` function to produce a four-panel set of maps.

```{r}
tmap::tm_shape(World) + 
  tmap::tm_polygons() + 
tmap::tm_shape(urb_1970_2030) + 
  tmap::tm_symbols(col = "black", 
                   border.col = "white",
                   size = "population_millions") +
  tmap::tm_facets(by = "year", 
                  nrow = 2, 
                  free.coords = FALSE)
```

The above code chunk demonstrates key features of faceted maps created with functions from the {tmap} package.

-   Shapes that do not have a facet variable are repeated (the countries in `World` in this case).
-   The `by =` argument which varies depending on a variable (`year` in this case).
-   nrow/ncol setting specifying the number of rows (and columns) that facets should be arranged into.
-   The `free.coords =` argument specifies whether each map has its own bounding box.

Small multiples are also generated by assigning more than one value to one of the aesthetic arguments.

For example here you map the happiness index (`HPI`) on one map and gross domestic product per person (`gdp_cap_est`) on another map. Both variables are in the `World` data frame.

```{r}
tmap::tm_shape(World) +
    tmap::tm_polygons(col = c("HPI", "gdp_cap_est"), 
                      style = c("pretty", "kmeans"),
                      palette = list("RdYlGn", "Purples"),
                      title = c("Happy Planet Index", "GDP per capita")) 
```

Note that the variable names must be in quotes (e.g., "HPI"). This is different than variables named in the {ggplot2} functions.

The maps are identical except for the variable being plotted. All arguments of the layer functions can be vectorized, one for each map. Arguments that normally take a vector, such as `palette =`, are placed in a `list()`.

Multiple map objects can also be arranged in a single plot with the `tmap::tmap_arrange()` function. Here you create two separate maps then arrange them.

```{r}
map1 <- tmap::tm_shape(World) +
           tmap::tm_polygons(col = "HPI", 
                             style = "pretty",
                             palette = "RdYlGn",
                             title = "Happy Planet Index") 

map2 <- tmap::tm_shape(World) +
           tmap::tm_polygons(col = "gdp_cap_est", 
                             style = "kmeans",
                             palette = "Purples",
                             title = "GDP per capita") 

tmap::tmap_arrange(map1, map2)
```

## Making a map interactive {.unnumbered}

A nice feature of the {tmap} package is that you can create an interactive map using the same code used to create a static map.

Consider again the boundary map of the contiguous 48 states.

```{r}
tmap::tm_shape(USA_48.sf) +
  tmap::tm_borders()
```

By default the map gets rendered directly to the Rmd screen or to the Plots window as a static image. To change the default to an interactive image you set the render mode to `"view"` in the `tmap::tmap_mode()` function.

Here you repeat the county boundary map after specifying the render mode.

```{r}
tmap::tmap_mode("view")

tmap::tm_shape(USA_48.sf) +
  tmap::tm_borders()
```

The county borders from your spatial data frame are overlaid on zoom-able Leaflet tiles. You can change the underlying layers by clicking on the layering symbol.

You can also create interactive maps with the `tmap::tmap_leaflet()` function.

The view mode in {tmap} also works with faceted plots. The argument sync in `tmap::tm_facets()` is used to produce multiple maps with synchronized zoom and pan settings.

Change the view mode back to a static plot.

```{r}
tmap::tmap_mode("plot")
```

Additional information

-   Why map projections matter <https://youtu.be/vVX-PrBRtTY>
-   Bivariate maps. See `Other_Rmds/BivariateMaps.Rmd`
-   See the {maptiles} package <https://github.com/riatelab/maptiles/>
-   Getting started with {tmap} <https://cran.r-project.org/web/packages/tmap/vignettes/tmap-getstarted.html>